import { subscribeKey as subKey } from 'valtio/vanilla/utils';
import { proxy, ref } from 'valtio/vanilla';
import { CoreHelperUtil } from '../utils/CoreHelperUtil.js';
import { StorageUtil } from '../utils/StorageUtil.js';
import { TransactionsController } from './TransactionsController.js';
import { ChainController } from './ChainController.js';
import {} from '@reown/appkit-wallet';
import { ModalController } from './ModalController.js';
import { ConnectorController } from './ConnectorController.js';
import { EventsController } from './EventsController.js';
import { OptionsController } from './OptionsController.js';
// -- State --------------------------------------------- //
const state = proxy({
    wcError: false,
    buffering: false,
    status: 'disconnected'
});
// eslint-disable-next-line init-declarations
let wcConnectionPromise;
// -- Controller ---------------------------------------- //
export const ConnectionController = {
    state,
    subscribeKey(key, callback) {
        return subKey(state, key, callback);
    },
    _getClient(chain) {
        return ChainController.getConnectionControllerClient(chain);
    },
    setClient(client) {
        state._client = ref(client);
    },
    async connectWalletConnect() {
        StorageUtil.setConnectedConnector('WALLET_CONNECT');
        if (CoreHelperUtil.isTelegram()) {
            if (wcConnectionPromise) {
                try {
                    await wcConnectionPromise;
                }
                catch (error) {
                    /* Empty */
                }
                wcConnectionPromise = undefined;
                return;
            }
            if (!CoreHelperUtil.isPairingExpired(state?.wcPairingExpiry)) {
                const link = state.wcUri;
                state.wcUri = link;
                return;
            }
            wcConnectionPromise = new Promise(async (resolve, reject) => {
                await ChainController.state?.universalAdapter?.connectionControllerClient
                    ?.connectWalletConnect?.(uri => {
                    state.wcUri = uri;
                    state.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
                })
                    .catch(reject);
                resolve();
            });
            this.state.status = 'connecting';
            await wcConnectionPromise;
            wcConnectionPromise = undefined;
            state.wcPairingExpiry = undefined;
            this.state.status = 'connected';
        }
        else {
            await ChainController.state?.universalAdapter?.connectionControllerClient?.connectWalletConnect?.(uri => {
                state.wcUri = uri;
                state.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
            });
        }
    },
    async connectExternal(options, chain, setChain = true) {
        await this._getClient(chain).connectExternal?.(options);
        if (setChain) {
            ChainController.setActiveNamespace(chain);
            StorageUtil.setConnectedConnector(options.type);
        }
    },
    async reconnectExternal(options) {
        await this._getClient().reconnectExternal?.(options);
        StorageUtil.setConnectedConnector(options.type);
    },
    async setPreferredAccountType(accountType) {
        ModalController.setLoading(true);
        const authConnector = ConnectorController.getAuthConnector();
        if (!authConnector) {
            return;
        }
        await authConnector?.provider.setPreferredAccount(accountType);
        await this.reconnectExternal(authConnector);
        ModalController.setLoading(false);
        EventsController.sendEvent({
            type: 'track',
            event: 'SET_PREFERRED_ACCOUNT_TYPE',
            properties: {
                accountType,
                network: ChainController.state.activeCaipNetwork?.caipNetworkId || ''
            }
        });
    },
    async signMessage(message) {
        return this._getClient().signMessage(message);
    },
    parseUnits(value, decimals) {
        return this._getClient().parseUnits(value, decimals);
    },
    formatUnits(value, decimals) {
        return this._getClient().formatUnits(value, decimals);
    },
    async sendTransaction(args) {
        return this._getClient().sendTransaction(args);
    },
    async getCapabilities(params) {
        return this._getClient().getCapabilities(params);
    },
    async grantPermissions(params) {
        return this._getClient().grantPermissions(params);
    },
    async estimateGas(args) {
        return this._getClient().estimateGas(args);
    },
    async writeContract(args) {
        return this._getClient().writeContract(args);
    },
    async getEnsAddress(value) {
        return this._getClient().getEnsAddress(value);
    },
    async getEnsAvatar(value) {
        return this._getClient().getEnsAvatar(value);
    },
    checkInstalled(ids, chain) {
        return this._getClient(chain).checkInstalled?.(ids) || false;
    },
    resetWcConnection() {
        state.wcUri = undefined;
        state.wcPairingExpiry = undefined;
        state.wcLinking = undefined;
        state.recentWallet = undefined;
        state.status = 'disconnected';
        TransactionsController.resetTransactions();
        StorageUtil.deleteWalletConnectDeepLink();
    },
    setWcLinking(wcLinking) {
        state.wcLinking = wcLinking;
    },
    setWcError(wcError) {
        state.wcError = wcError;
        state.buffering = false;
    },
    setRecentWallet(wallet) {
        state.recentWallet = wallet;
    },
    setBuffering(buffering) {
        state.buffering = buffering;
    },
    setStatus(status) {
        state.status = status;
    },
    async disconnect() {
        try {
            const connectionControllerClient = this._getClient();
            const siwx = OptionsController.state.siwx;
            if (siwx) {
                const activeCaipNetwork = ChainController.getActiveCaipNetwork();
                const address = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
                if (activeCaipNetwork && address) {
                    await siwx.revokeSession(activeCaipNetwork.caipNetworkId, address);
                }
            }
            await connectionControllerClient?.disconnect();
            this.resetWcConnection();
        }
        catch (error) {
            throw new Error('Failed to disconnect');
        }
    },
    /**
     * @experimental - This is an experimental feature and may be subject to change.
     * Initializes SIWX if available.
     * This is not yet considering One Click Auth.
     */
    async initializeSWIXIfAvailable() {
        const siwx = OptionsController.state.siwx;
        const address = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
        const network = ChainController.getActiveCaipNetwork();
        if (!(siwx && address && network)) {
            return;
        }
        if (OptionsController.state.isSiweEnabled) {
            console.warn('SIWE is enabled skipping experimental SIWX initialization');
            return;
        }
        const client = this._getClient(network?.chainNamespace);
        try {
            const sessions = await siwx.getSessions(network.caipNetworkId, address);
            if (sessions.length) {
                return;
            }
            await ModalController.open({
                view: StorageUtil.getConnectedConnector() === 'AUTH' ? 'ApproveTransaction' : 'SIWXSignMessage'
            });
            const siwxMessage = await siwx.createMessage({
                chainId: network.caipNetworkId,
                accountAddress: address
            });
            const message = siwxMessage.toString();
            const signature = await client.signMessage(message);
            await siwx.addSession({
                data: siwxMessage,
                message,
                signature
            });
            ModalController.close();
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.error('Failed to initialize SIWX', error);
            ModalController.setLoading(true);
            await client.disconnect().finally(() => {
                ModalController.setLoading(false);
            });
        }
    }
};
//# sourceMappingURL=ConnectionController.js.map